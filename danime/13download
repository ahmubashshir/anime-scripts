#!/bin/bash
# shellcheck disable=SC2086
# shellcheck disable=SC1091
# shellcheck disable=SC1090
# shellcheck disable=SC2034
# shellcheck disable=SC2154
# shellcheck disable=SC2016
# shellcheck disable=SC2143
source libbash
source spinner
sp=$sp31
SPINNER_DELAY=0.04
source "$(dirname "$0")"/14parse
DEBUG=${DEBUG:-false}
#start:code
SUPPORTED_HOSTS='mp4upload\|mp4.sh\|trollvid\|vidstreaming'
da_get_episede() {
	tr=${1##*-}
	if (($# == 0)); then
		return 1
	else
		local IFS="$IFS" tr="$tr"
		IFS=$'\n'
		tput sc
		set +x
		start_spinner "Fetching info about  episode[dubbedanime:$(echo "$1" | rev | cut -d/ -f1 | rev | cut -d- -f1)]"
		${DEBUG:-false} && set -x
		if ! [[ $1 =~ ^http* ]]; then
			local d
			d=$1
			shift
			set "https://ww5.dubbedanime.net/$d" "$@"
			unset d
		fi
		parse_episede_page="$(curl "$1" 2> /dev/null)"
		episode_type=$(echo "$1" | cut -d/ -f4)
		if echo "$tr" | grep -qvw 'dubbed\|subbed'; then
			tr=dubbed
		fi
		if [[ $tr = dubbed ]] || [[ $tr = subbed ]]; then
			filter='grep \"type\":\"$tr'
		else
			filter="cat"
		fi
		if [ "$episode_type" = "episode" ]; then

			ep_title=$(echo "$parse_episede_page" | grep -v doctype | sed -n "/<h1 class='dosis ep-title'>/,/<\/h1>/{/<h1 class='dosis ep-title'>/d;s| *</h1>||g;p}")
			if ! [[ ${ep_title##* } =~ ^[[:digit:]]+$ ]]; then
				ep_title="${ep_title% *} $(if (($3 > 1)); then
					echo "${ep_title##* } $2" | tr '[:upper:]' '[:lower:]'
				else
					echo "${ep_title##* }" | tr '[:upper:]' '[:lower:]'
				fi)"
			else
				local ep_number
				ep_number=${ep_title##* }
				ep_title=${ep_title% *}
				ep_title="${ep_title% *} $(echo "${ep_title##* } $ep_number" | sed 's| $||g;s|episode|ep|gI;s|ova|ova|gI;s|ona|ona|gI;s|movie|movie|gI;s|special|special|gI')"
			fi
			ep_id_list=$(
				echo "$parse_episede_page" | sed 's|\;$||g' | grep var\ episode | cut -d= -f2 | jsonparser -q | grep '\[\"videos\",[[:digit:]]*\]' | tr -d '[:blank:]' | cut -d\] -f2- | grep $SUPPORTED_HOSTS | eval $filter | awk -F, '{print $1","$2","$3"}";}'
				curl "https://vid.xngine.com/api/episode/$(echo "$parse_episede_page" | grep 'var episode' | sed 's|;$||g' | cut -d= -f2 | jsonparser -b -q | grep slug | tr -s '[:blank:]' \  | cut -d\  -f2 | tr -d \")" -s 2> /dev/null | jsonparser -q | grep -E '^\[[[:digit:]]+\]' | tr -s '[:blank:]' \  | cut -d\  -f2 | grep $SUPPORTED_HOSTS | eval $filter
			)

			if [ -z "$ep_id_list" ]; then
				tr=subbed
				ep_id_list=$(
					echo "$parse_episede_page" | sed 's|\;$||g' | grep var\ episode | cut -d= -f2 | jsonparser -q | grep '\[\"videos\",[[:digit:]]*\]' | tr -d '[:blank:]' | cut -d\] -f2- | grep $SUPPORTED_HOSTS | eval $filter | awk -F, '{print $1","$2","$3"}";}'
					curl "https://vid.xngine.com/api/episode/$(echo "$parse_episede_page" | grep 'var episode' | sed 's|;$||g' | cut -d= -f2 | jsonparser -b -q | grep slug | tr -s '[:blank:]' \  | cut -d\  -f2 | tr -d \")" -s 2> /dev/null | jsonparser -q | grep -E '^\[[[:digit:]]+\]' | tr -s '[:blank:]' \  | cut -d\  -f2 | grep $SUPPORTED_HOSTS | eval $filter
				)
			fi
			ep_file_name="$(echo "$ep_title" | replace_invalid)-$tr.mp4"
		elif [ "$episode_type" = "cartoon" ]; then

			ep_title=$(echo "$parse_episede_page" | grep -v doctype | sed -n "/<h1 class='dosis ep-title'>/,/<\/h1>/{/<h1 class='dosis ep-title'>/d;s| *</h1>||g;p}")
			if ! [[ ${ep_title##* } =~ ^[[:digit:]]+$ ]]; then
				ep_title="${ep_title% *} $(if (($3 > 1)); then
					echo "${ep_title##* } $2" | tr '[:upper:]' '[:lower:]'
				else
					echo "${ep_title##* }" | tr '[:upper:]' '[:lower:]'
				fi)"
			else
				local ep_number
				ep_number=${ep_title##* }
				ep_title=${ep_title% *}
				ep_title="${ep_title% *} $(echo "${ep_title##* } $ep_number" | sed 's| $||g;s|episode|ep|gI;s|ova|ova|gI;s|ona|ona|gI;s|movie|movie|gI;s|special|special|gI')"
			fi
			ep_id_list=$(echo "$parse_episede_page" | sed 's|\;$||g' | grep var\ episode | cut -d= -f2 | jsonparser -q | grep '\[\"videos\",[[:digit:]]*\]' | tr -d '[:blank:]' | cut -d\] -f2- | grep $SUPPORTED_HOSTS | sort)
			ep_file_name="$(echo "$ep_title" | replace_invalid).mp4"
		fi
		ep_id_list="$(echo "$ep_id_list" | awk '!x[$0]++')"
		set +x
		if [ -n "$parse_episede_page" ] && [ -n "$ep_title" ]; then
			stop_spinner 0
		else
			stop_spinner 1
			return 1
		fi
		tput rc
		vbar
		vbar "$ep_title" true
		vbar "ID:$(echo "$1" | rev | cut -d/ -f1 | rev | cut -d- -f1)"
		vbar
		if [ "$(echo "$ep_id_list" | wc -l)" -eq 1 ] && [ -z "$REPLACE_ON_ERROR" ]; then
			REPLACE_ON_ERROR=true
		elif [ "$(echo "$ep_id_list" | wc -l)" -gt 1 ] && [ -z "$REPLACE_ON_ERROR" ]; then
			REPLACE_ON_ERROR=false
		fi
		for n in $ep_id_list; do
			ep_file_url=
			${DEBUG:-false} && set -x
			ep_file_host=$(echo "$n" | jsonparser -b -q | tr -d \" | tr \[:blank:\] \  | tr -s \  | grep '^\[host\]' | cut -d\  -f2)
			ep_file_id=$(echo "$n" | jsonparser -b -q | tr -d \" | tr \[:blank:\] \  | tr -s \  | grep '^\[id\]' | cut -d\  -f2)
			set +x
			start_spinner "Getting url from provider[$ep_file_host:$ep_file_id]"
			${DEBUG:-false} && set -x
			if [ "$(echo "$ep_id_list" | wc -l)" -eq 1 ]; then
				while [ -z "$ep_file_url" ]; do
					sleep 1
					ep_file_url=$(parse_episede_id "$n")
				done
			else
				ep_file_url=$(parse_episede_id "$n")
			fi
			if [[ $ep_file_url =~ https://[[:alnum:][:punct:]]*/[[:alnum:][:punct:]]*.mp4[[:alnum:][:punct:]]* ]]; then
				stop_spinner 0
				if ! ([[ $tr = dubbed ]] || [[ $tr = subbed ]]); then
					tr=$(echo "$n" | jsonparser -b -q | tr -d \" | tr \[:blank:\] \  | tr -s \  | grep '^\[type\]' | cut -d\  -f2)
				fi
				if [[ $(curl -kLsI "$ep_file_url" 2> /dev/null | grep -i '^http/' | tail -1 | cut -d\  -f2) =~ ^4[[:digit:]][[:digit:]]$ ]]; then
					echo 404 not found.
					continue
				fi
				if ${SKIP_DOWNLOAD:-false}; then
					return 0
				fi
				compare_episode "$ep_file_name" "$ep_file_url"
				ret=$?
				if ((ret == 0)); then
					download "$ep_file_name" "$ep_file_url"
					return 0
				elif (
					((ret == 4)) \
						&& (
							${REPLACE_ON_ERROR:-false} || ((${failed_tests:-0} <= 5))
						) && ! ${NO_REPLACE:-false}
				) || ((ret == 5)) || (${REPLACE_MANUAL:-false} && ((ret == 3))); then
					rm "$ep_file_name"
					download "$ep_file_name" "$ep_file_url"
					return 0
				else
					echo -e "\nFile doesn't match."
				fi
			elif [[ $ep_file_url =~ unimplemented:[:alnum:]* ]]; then
				stop_spinner 1
				echo "URL extractor not available for ${ep_file_url##*:}"
			elif [[ $ep_file_url =~ https://[[:alnum:][:punct:]]*/[[:alnum:][:punct:]]*.m3u8[[:alnum:][:punct:]]* ]]; then
				stop_spinner 1
				echo "M3U8 downloader is not implemented." 1>&2
				echo -e "Please run \n  \`ffmpeg -i \"$ep_file_url\" -c copy \"$PWD/$ep_file_name\"\`"
			else
				stop_spinner 1
				echo "URL Parsing error"
			fi
		done
	fi
}

download() {
	local s1 s2 ret
	s1=$(wget --spider --no-check-certificate -qS "$2" 2>&1 | awk '/Content-Length/ { print $2 }' | tail -1)
	s2=$(stat -c%s "$1" 2> /dev/null || echo 0)
	if ((s1 >= s2)); then
		fget "$2" "$1"
		ret=$?
	else
		echo "Manually downloaded $1[$(byte_hr "$s2")],skipping."
	fi
	if ((ret == 0)) || ([ "$CHECK_FILE" == "false" ]); then
		return 0
	fi
	start_spinner "Checking $(ellipsis 40 "$1") integrity"
	${DEBUG:-false} && set -x
	if [ -n "$(ffmpeg -v error -map 0:0 -f null - -i "$1" 2>&1 | grep -v '^\[\|^[[:blank:]]')" ] || ((s1 < s2)); then
		stop_spinner 1
		echo "$1 is corrupted"
		return $((ret + 1))
	else
		stop_spinner 0
		return $((ret + $?))
	fi
}
compare_episode() {
	${DEBUG:-false} && set -x
	local size wsize BS="$BS" hash1 hash2
	if [ ! -e "$1" ] || ([ -n "$CHECK_FILE" ] && [ "$CHECK_FILE" == "false" ]); then
		return 0
	elif [ "$CHECK_FILE" == "error" ]; then
		return 2
	fi
	size=$(stat -c%s "$1")
	if ((${BS:-524288} >= size / 2)); then
		BS=$(echo "$size/200" | bc | cut -d. -f1)
	fi
	wsize=$(curl -LksI "$2" 2> /dev/null | sed -E '/^HTTP\/[12.]+ 3[0-9][0-9]/,/^\r$/d' | dos2unix -f | awk '/Content-Length/ { print $2 }' | tr -d '[:blank:]')
	if ((size > wsize)); then
		return 3
	elif ((size == 0)); then
		return 0
	fi
	${DEBUG:-false} && set -x
	if ! (dd if="$1" of=/dev/null bs=1 count=1 status=none 2> /dev/null && exit "$(ffprobe -hide_banner -loglevel 16 "$1" 2>&1 | wc -l)"); then
		return 5
	fi
	${DEBUG:-false} && set +x
	failed_tests=${TOTAL_CHECKS:-10}
	offsets=($(srand 0 $((size - ${BS:-524288})) $((BS / 2)) ${TOTAL_CHECKS:-10}))
	for ((i = 0; i < ${TOTAL_CHECKS:-10}; i++)); do
		printf "\rComparing episode[test:%d]" "$((i + 1))"
		start=${offsets[$i]}
		hash1="$(dd bs=1 count="${BS:-524288}" status=none if="$1" skip="$start" | sha256sum | cut -d\  -f1)"
		hash2="$(curl -kr "$start-$((start + ${BS:-524288} - 1))" "$2" 2> /dev/null | sha256sum | cut -d\  -f1)"
		test "$hash1" = "$hash2" && failed_tests=$((failed_tests - 1))
		test "$hash1" = "$hash2" || echo -e "\rComparing episode[test:$((i + 1)):fail]"
		test "$hash1" = "$hash2" || return 4
	done
	echo -e "\rComparing episode[test:1-${TOTAL_CHECKS:-10}:pass]"
	return 0
}
#end:code
if ! ([[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] || [[ -n $BASH_VERSION ]] && (return 0 2> /dev/null)); then
	da_get_episede "$@"
fi

