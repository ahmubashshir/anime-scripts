#!/bin/bash
# shellcheck disable=SC2086
# shellcheck disable=SC1091
# shellcheck disable=SC1090
# shellcheck disable=SC2034
# shellcheck disable=SC2154
# shellcheck disable=SC2016
# shellcheck disable=SC2143
# shellcheck disable=SC2119
source libbash
source spinner
sp=$sp31
SPINNER_DELAY=0.04
. 14parse
. 01include
DEBUG=${DEBUG:-false}
#start:code
SUPPORTED_HOSTS='mp4upload\|mp4.sh\|trollvid\|vidstreaming'
da_add_auth()
{
	while read -r ep_id;do if echo "$ep_id"|jq -r '.host'|grep -q 'trollvid\|mp4\.sh';then echo "$ep_id"|jq -Mc ". + { \"auth\" : \"$(echo "$@"|jq -r '.auth')\"}";else echo "$ep_id";fi;done
}
da_get_episede() {
	tr=${1##*-}
	if (($# == 0)); then
		return 1
	else
		local IFS file_num ret progress total_pw ep_number ep_title
		progress=$4
		total_pw=$5
		local tr="$tr"
		IFS=$'\n'
		case ${1%%/*} in
			episode) episode_type=episode;;
			cartoon|c) episode_type=cartoon;;
			*) echo ${1%%/*}:invalid;;
		esac
		start_spinner "Fetching info about episode[id:$(echo "$1" | rev | cut -d/ -f1 | rev | cut -d- -f1)]"
		${DEBUG:-false} && set -x
		if ! [[ $1 =~ ^http* ]]; then
			local d
			d=$1
			shift
			set "https://ww5.dubbedanime.net/$d" "$@"
			unset d
		fi
		parse_episede_page="$(curl -s "$1" | sed 's|\;$||g' | grep 'var\ episode\|var\ xuath' | cut -d= -f2-)"
		parse_episede_page="$(echo "$parse_episede_page" | head -1|jq -c ". + { \"auth\" : \"$(echo "$parse_episede_page"|tail -1|cut -d\' -f2)\"}")"
		if echo "$tr" | grep -qvw 'dubbed\|subbed'; then
			tr=dubbed
		fi
		if [[ $tr = dubbed ]] || [[ $tr = subbed ]]; then
			filter="grep '\"type\":\"$tr'"
		else
			filter="cat"
		fi
		if [ -z "$parse_episede_page" ];then
			stop_spinner 1
			echo Episode not available.
			${NOBREAK:-false} && return 0 || return 1
		fi
		if [ "$episode_type" = "episode" ]; then

			ep_title=$(echo "$parse_episede_page" | jq -r '.name.default')
			if ! [[ ${ep_title##* } =~ ^[[:digit:].-]+$ ]]; then
				if [ "${ep_title% *}" = "${ep_title##* }" ]; then
					ep_title="$TITLE $ep_title"
				fi
				ep_title="${ep_title% *} $(echo "${ep_title##* } $2" | tr '[:upper:]' '[:lower:]')"
			else
				local ep_number
				ep_number=$(echo "$parse_episede_page" | jq -r '.number')
				if [ "$ep_number" = "null" ]; then
					ep_number=$(echo "$parse_episede_page" | jq -r '.name.default' | rev | cut -d' ' -f1 | rev)
				fi
				ep_title=${ep_title% *}
				if [ "${ep_title% *}" = "${ep_title##* }" ]; then
					ep_title="$TITLE $ep_title"
				elif [[ "${ep_title% *}" =~ ${ep_title##* }$ ]]; then
					ep_title="$(echo "$ep_title"|tr ' ' $'\n'|head -n -1|xargs echo)"
				fi
				ep_title="${ep_title% *} $(echo "${ep_title##* } $ep_number" | sed 's|episode|ep|gI;s|ova|ova|gI;s|ona|ona|gI;s|movie|movie|gI;s|special|special|gI')"
			fi
			ep_title="$(echo "$ep_title"|sed 's| *$||g;s|^ *||g')"
			ep_id_list=$(
				echo "$parse_episede_page" | jq --tab -r '.videos' | grep -v '"date"' | tail +2 | head -n -1 | awk '!match($0,"}"){printf $0};match($0,"}")' | tr -d \\t | sed 's/,},/}/;s/,}/}/' |da_add_auth "$parse_episede_page"| jq -Mc . | grep '"id"' | grep $SUPPORTED_HOSTS | eval $filter
				curl "https://vid.xngine.com/api/episode/$(echo "$parse_episede_page" | jq -r '.slug')" -s 2> /dev/null | jq '.' | tail +2 | head -n -1 | awk '!match($0,"}"){printf $0};match($0,"}")' | grep -v status | sed 's/,$//' | jq -Mc . | grep '"id"' | grep $SUPPORTED_HOSTS | eval $filter
			)

			if [ -z "$ep_id_list" ]; then
				tr=subbed
				ep_id_list=$(
					echo "$parse_episede_page" | jq --tab -r '.videos' | grep -v '"date"' | tail +2 | head -n -1 | awk '!match($0,"}"){printf $0};match($0,"}")' | tr -d \\t | sed 's/,},/}/;s/,}/}/' |da_add_auth "$parse_episede_page"| jq -Mc . | grep '"id"' | grep $SUPPORTED_HOSTS | eval $filter
					curl "https://vid.xngine.com/api/episode/$(echo "$parse_episede_page" | jq -r '.slug')" -s 2> /dev/null | jq '.' | tail +2 | head -n -1 | awk '!match($0,"}"){printf $0};match($0,"}")' | grep -v status | sed 's/,$//' | jq -Mc . | grep '"id"' | grep $SUPPORTED_HOSTS | eval $filter
				)
			fi
			if echo "$1" | grep -q "-extra-[[:digit:]]*-english-subbed$"; then
				ep_title="${ep_title// ep / extra }"
			fi
			ep_file_name="$(echo "$ep_title" | replace_invalid)-$tr.mp4"
		elif [ "$episode_type" = "cartoon" ]; then
			ep_title="$TITLE"
			ep_number="$(echo "$parse_episede_page" | jq -r '.number')"
			ep_title="$ep_title ep $ep_number"
			ep_id_list=$(echo "$parse_episede_page" | jq --tab -r '.videos' | grep -v '"date"' | tail +2 | head -n -1 | awk '!match($0,"}"){printf $0};match($0,"}")' | tr -d \\t | sed 's/,},/}/;s/,}/}/' |da_add_auth "$parse_episede_page"| jq -Mc . | grep '"id"' | grep $SUPPORTED_HOSTS | awk -e '!seen[$0]++')
			ep_file_name="$(echo "$ep_title" | replace_invalid).mp4"
		fi
		ep_id_list="$(echo "$ep_id_list" | awk -e '!seen[$0]++' | awk '/'"${PREFERRED_HOSTS//,/\\\|}"'/{print};!/'"${PREFERRED_HOSTS//,/\\|}"'/{lines[a++]=$0};END{for(i in lines) print lines[i]}')"
		set +x
		if [ -n "$parse_episede_page" ] && [ -n "$ep_title" ]; then
			stop_spinner 0
		else
			stop_spinner 1
			return 1
		fi
		ep_title=$(ellipsis $(($(tput cols) - 8)) "$ep_title")
		vbar
		vbar "$ep_title" true
		vbar "ID:$(echo "$1" | rev | cut -d/ -f1 | rev | cut -d- -f1)$([ -n "$progress" ] && [ -n "$total_pw" ] && echo " - Progress:$progress/$total_pw")"
		vbar
		if [ "$(echo "$ep_id_list" | wc -l)" -eq 1 ] && [ -z "$REPLACE_FAIL" ]; then
			REPLACE_FAIL=true
		elif [ "$(echo "$ep_id_list" | wc -l)" -gt 1 ] && [ -z "$REPLACE_FAIL" ]; then
			REPLACE_FAIL=false
		fi
		${DEBUG:-false} && set -x
		for n in $ep_id_list; do
			if [ -n "$_sp_pid" ]; then
				stop_spinner 1
			fi
			ep_file_url=
			ep_file_host=$(echo "$n" | jq -r '.host')
			ep_file_id=$(echo "$n" | jq -r '.id'|xargs basename -a)
			set +x
			start_spinner "Getting url from provider[$ep_file_host:$(ellipsis 15 "$ep_file_id")]"
			${DEBUG:-false} && set -x
			if [ "$(echo "$ep_id_list" | wc -l)" -eq 1 ]; then
				while [ -z "$ep_file_url" ]; do
					sleep 1
					ep_file_url=$(parse_episede_id "$n")
				done
			else
				ep_file_url=$(parse_episede_id "$n")
			fi
			for ep_file_url_current in $ep_file_url; do
				if [[ $ep_file_url_current =~ error:* ]]; then
					ep_file_url=
					stop_spinner 1
					echo "[Error] ${ep_file_url_current#*:}"
					continue
				elif [[ $ep_file_url_current =~ unimplemented:[:alnum:]* ]]; then
					ep_file_url=
					stop_spinner 1
					echo "[Error] URL extractor not implemented for ${ep_file_url##*:}"
					continue 2
				elif [[ $ep_file_url_current =~ https://[[:alnum:][:punct:]]*/[[:alnum:][:punct:]]*.m3u8[[:alnum:][:punct:]]* ]]; then
					ep_file_url=
					stop_spinner 1
					echo "[Warn] HLS video downloader is not implemented." 1>&2
					echo -e "Please run \n  \`ffmpeg -i \"$ep_file_url_current\" -c copy \"$PWD/$ep_file_name\"\`"
					continue 2
				elif remote_exist "$ep_file_url_current"; then
					continue
				else
					ep_file_url=
					stop_spinner 1
					echo "[Error] 404 not found."
					continue 2
				fi
			done
			if [ -n "$ep_file_url" ]; then
				stop_spinner 0
			else
				continue
			fi
			if [[ $(echo "$ep_file_url" | wc -l) -gt 1 ]]; then
				file_num=0
			fi
			for ep_file_url_current in $ep_file_url; do
				if [ -n "$file_num" ]; then
					file_num=$((file_num + 1))
					if [ "$episode_type" = "cartoon" ]; then
						ep_file_name="$(echo "$ep_title" | replace_invalid)-part$file_num.mp4"
					else
						ep_file_name="$(echo "$ep_title" | replace_invalid)-part$file_num-$tr.mp4"
					fi
				fi
				ep_file_name="${ep_file_name//---/--}"
				if ! { [[ $tr = dubbed ]] || [[ $tr = subbed ]] ; }; then
					tr=$(echo "$n" | jq -r '.type')
				fi
				if ${SKIP_DOWNLOAD:-false}; then
					continue
				fi
				compare_episode "$ep_file_name" "$ep_file_url_current"
				ret=$?
				if ((ret == 0)); then
					download "$ep_file_name" "$ep_file_url_current"
				elif (
					((ret == 4)) \
						&& (
							${REPLACE_FAIL:-false} || ((${failed_tests:-0} <= 5))
						) && ! ${NO_REPLACE:-false}
				) || ((ret == 5)) || (${REPLACE_MANUAL:-false} && ((ret == 3))); then
					#echo " overwriting"
					rm "$ep_file_name"
					download "$ep_file_name" "$ep_file_url_current"
				else
					echo "File doesn't match."
					continue 2
				fi
			done
			break
		done
		if [ -z "$ep_file_url" ]; then
			if [ -n "$_sp_pid" ]; then
				stop_spinner 1
			fi
			echo "Episode not available."
		fi
	fi
}

download() {
	local s1 s2 ret tried

	s1=$(wget --spider --no-check-certificate -qS "$2" 2>&1 | awk '/Content-Length/ { print $2 }' | tail -1)
	s2=$(stat -c%s "$1" 2> /dev/null || echo 0)
	tried=1
	if ((s1 >= s2)); then
		until fget "$2" "$1"; do
			ret=$?
			if [[ $ret = 10 ]];then
				return
			elif ((tried <= ${MAX_TRY:-5})); then
				tput cuu 2
				((tried>1)) && (tput el1;tput el;tput cuu1)
				tput el1
				tput el
				echo "Retrying...[$tried]"
				((tried+=1))
			else
				break
			fi
		done
	else
		echo "Manually downloaded $1[$(byte_hr "$s2")],skipping."
	fi
	if ((ret == 0)) || [ "$CHECK_FILE" == "false" ]; then
		return 0
	fi
	start_spinner "Checking $(ellipsis 40 "$1") integrity"
	${DEBUG:-false} && set -x
	if [ -n "$(ffmpeg -v error -map 0:0 -f null - -i "$1" 2>&1 | grep -v '^\[\|^[[:blank:]]')" ] || ((s1 < s2)); then
		stop_spinner 1
		echo "$1 is corrupted"
		return $((ret + 1))
	else
		stop_spinner 0
		return $((ret + $?))
	fi
}
compare_episode() {
	${DEBUG:-false} && set -x
	local size wsize BS="$BS" hash1 hash2
	if [[ $BS =~ ^[[:digit:].]+[[:digit:]kKmM]$ ]]; then
		BS=$(echo "$BS" | byte_mr)
	else
		BS=524288
	fi
	if [ ! -e "$1" ] || { [ -n "$CHECK_FILE" ] && [ "$CHECK_FILE" == "false" ]; }; then
		return 0
	elif [ "$CHECK_FILE" == "error" ]; then
		return 2
	fi
	size=$(stat -c%s "$1")
	if ((${BS:-524288} >= size / 2)); then
		BS=$(echo "$size/200" | bc | cut -d. -f1)
	fi
	wsize=$(curl -LksI "$2" 2> /dev/null | sed -E '/^HTTP\/[12.]+ 3[0-9][0-9]/,/^\r$/d' | tr -s '\r' '\n' | awk '/Content-Length/ { print $2 }' | tr -d '[:blank:]')
	if ((size > wsize)); then
		return 3
	elif ((size == 0)); then
		return 0
	fi
	${DEBUG:-false} && set -x
	if ! (dd if="$1" of=/dev/null bs=1 count=1 status=none 2> /dev/null && exit "$(ffprobe -hide_banner -loglevel 14 "$1" 2>&1 | wc -l)"); then
		return 5
	fi
	if command -v mediainfo &> /dev/null; then
		asize=$(mediainfo "$1" 2> /dev/null | tr -s '[:blank:]' \  | grep -i '^stream size' | sed 's|: |:|g' | cut -d: -f2 | cut -d\  -f1 | awk '{printf $0"*1048576+"};END {printf "0\n"}' | bc | cut -d\. -f1)
	else
		asize=$size
	fi
	if ((asize > wsize)); then
		return 3
	fi
	${DEBUG:-false} && set +x
	failed_tests=${TOTAL_CHECKS:-10}
	IFS=' ' read -ra offsets < <(srand 0 $((size - ${BS:-524288})) $((BS / 2)) "${TOTAL_CHECKS:-10}")
	if [ "${#offsets}" = "0" ]; then
		exit 1
	fi
	for ((i = 0; i < ${TOTAL_CHECKS:-10}; i++)); do
		printf "\rComparing episode[test:%d]" "$((i + 1))"
		start=${offsets[$i]}
		hash1="$(dd bs=1 count="${BS:-524288}" status=none if="$1" skip="$start" | sha256sum | cut -d\  -f1)"
		hash2="$(curl -kr "$start-$((start + ${BS:-524288} - 1))" "$2" 2> /dev/null | sha256sum | cut -d\  -f1)"
		test "$hash1" = "$hash2" && failed_tests=$((failed_tests - 1))
		test "$hash1" = "$hash2" || echo -e "\rComparing episode[test:$((i + 1)):fail]"
		test "$hash1" = "$hash2" || return 4
	done
	echo -e "\rComparing episode[test:1-${TOTAL_CHECKS:-10}:pass]"
	return 0
}
#end:code
if ! { [[ -n $ZSH_EVAL_CONTEXT && $ZSH_EVAL_CONTEXT =~ :file$ ]] || { [[ -n $BASH_VERSION ]] || [[ $0 =~ bin/bashdb$ ]]; } && { return 0 2> /dev/null ;};}; then
	da_get_episede "$@"
fi
